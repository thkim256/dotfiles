#+TITLE: Emacs configuration file
#+AUTHOR: thkim256
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* About
  이 설정파일은 [[http://orgmode.org][Org mode]]로 작성된 이맥스 구성 파일이다.
  전체적인 내용은 [[https://github.com/larstvei/dot-emacs][Larstvei Emacs]]를 기반으로 작성되었다. 

  Clone the repo.
  #+BEGIN_SRC sh :tangle no
  git clone https://github.com/thkim256/dot-emacs
  #+END_SRC

  And finally
  #+BEGIN_SRC sh :tangle no
  mv dot-emacs ~/.emacs.d
  #+END_SRC

* Configurations
** Meta

   =init.el= 파일을 해당 파일로 replace하는 방식으로 구성 파일을 설정.

   #+BEGIN_SRC emacs-lisp :tangle no
   ;; This file replaces itself with the actual configuration at first run.

   ;; We can't tangle without org!
   (require 'org)
   ;; Open the configuration
   (find-file (concat user-emacs-directory "init.org"))
   ;; tangle it
   (org-babel-tangle)
   ;; load it
   (load-file (concat user-emacs-directory "init.el"))
   ;; finally byte-compile it
   (byte-compile-file (concat user-emacs-directory "init.el"))
   #+END_SRC

   자동 생성되는 =init.el= 의 =git= 추적 OFF

   #+BEGIN_SRC sh :tangle no
   git update-index --assume-unchanged init.el
   # git update-index --no-assume-unchanged init.el
   #+END_SRC

   init-file을 lexical scope로 설정되도록 구성

   c.f. [[https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding][DynamicBinding Vs LexicalBinding]]

   #+BEGIN_SRC emacs-lisp
   ;;; -*- lexical-binding: t -*-
   #+END_SRC


   =init.el= 파일 추출

   #+BEGIN_SRC emacs-lisp
   (defun tangle-init ()
     "If the current buffer is 'init.org' the code-blocks are
   tangled, and the tangled file is compiled."
     (when (equal (buffer-file-name)
                  (expand-file-name (concat user-emacs-directory "init.org")))
       ;; Avoid running hooks when tangling.
       (let ((prog-mode-hook nil))
         (org-babel-tangle)
         (byte-compile-file (concat user-emacs-directory "init.el")))))

   (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC

   =private.el= 에 개인 구성 파일을 설정하고, 있다면 같이 로딩한다.

   #+BEGIN_SRC emacs-lisp
   (add-hook
    'after-init-hook
    (lambda ()
      (let ((private-file (concat user-emacs-directory "private.el")))
        (when (file-exists-p private-file)
          (load-file private-file)))))
   #+END_SRC

** Packages

   기본 패키지 로딩 (common lisp 패키지 로딩 추가)

   #+BEGIN_SRC emacs-lisp
   (require 'cl)
   (require 'package)
   (package-initialize)
   #+END_SRC

   패키지 저장소 등록

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
   (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))

   (add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)
   #+END_SRC

   사용하는 전체 패키지 로딩 및 설치

   #+BEGIN_SRC emacs-lisp
   (let* ((package--builtins nil)
          (packages
           '(auto-compile         ; automatically compile Emacs Lisp libraries
             cider                ; Clojure Interactive Development Environment
             clj-refactor         ; A collection of clojure refactoring functions
             company              ; Modular text completion framework
             company-go           ; Golang company
             define-word          ; display the definition of word at point
             diminish             ; Diminished modes from modeline
             drag-stuff           ; Drag stuff around in Emacs
             evil                 ; Vim mode support
             evil-mu4e            ; mu4e evil support
             expand-region        ; Increase selected region by semantic units
             focus                ; Dim color of text in surrounding sections
             idle-require         ; load elisp libraries while Emacs is idle
             geiser               ; GNU Emacs and Scheme talk to each other
             git-gutter-fringe    ; Fringe version of git-gutter.el
             go-mode              ; Golang
             go-tag               ; Golang support tag
             go-direx             ; Golang support direx
             golden-ratio         ; Automatic resizing windows to golden ratio
             haskell-mode         ; A Haskell editing mode
             helm                 ; Incremental and narrowing framework
             helm-ag              ; the silver searcher with helm interface
             helm-company         ; Helm interface for company-mode
             helm-dash            ; Offline documentation using Dash docsets.
             helm-projectile      ; Helm integration for Projectile
             helm-swoop           ; Efficiently hopping squeezed lines
             jedi                 ; Python auto-completion for Emacs
             js2-mode             ; Improved JavaScript editing mode
             magit                ; control Git from Emacs
             markdown-mode        ; Emacs Major mode for Markdown-formatted files
             material-theme       ; A Theme based on Google Material Design
             mu4e-alert           ; mu4e alert support
             multiple-cursors     ; Multiple cursors for Emacs
             olivetti             ; Minor mode for a nice writing environment
             ob-go                ; Golang org babel support
             org                  ; Outline-based notes management and organizer
             org-ref              ; citations bibliographies in org-mode
             paredit              ; minor mode for editing parentheses
             pdf-tools            ; Emacs support library for PDF files
             projectile           ; Manage and navigate projects in Emacs easily
             plantuml-mode        ; Plantuml
             slime                ; Superior Lisp Interaction Mode for Emacs
             try                  ; Try out Emacs packages
             which-key)))         ; Display available keybindings in popup
     (ignore-errors ;; This package is only relevant for Mac OS X.
       (when (memq window-system '(mac ns))
         (push 'exec-path-from-shell packages)
         (push 'reveal-in-osx-finder packages))
       (let ((packages (remove-if 'package-installed-p packages)))
         (when packages
           ;; Install uninstalled packages
           (package-refresh-contents)
           (mapc 'package-install packages)))))
   #+END_SRC
   
** Mac OS X

   Mac Os X 에서의 설정 추가 
   =Command=-key as the =Meta=-key.

   #+BEGIN_SRC emacs-lisp
   (when (eq system-type 'darwin)
     (setq ns-pop-up-frames nil
           mac-option-modifier nil
           mac-command-modifier 'meta
           x-select-enable-clipboard t)
     (exec-path-from-shell-initialize)
     (when (fboundp 'mac-auto-operator-composition-mode)
       (mac-auto-operator-composition-mode 1)))'
   #+END_SRC
** Require

   Emacs 초기 구성에 필요하지 않거나, 오래걸리는 항목은 지연로딩을 사용.

   #+BEGIN_SRC emacs-lisp
   (require 'idle-require)             ; Need in order to use idle-require

   (dolist (feature
            '(auto-compile             ; auto-compile .el files
              jedi                     ; auto-completion for python
              ob-go                    ; Golang
              ox-md                    ; Markdown exporter (from org)
              recentf                  ; recently opened files
              tex-mode))               ; TeX, LaTeX, and SliTeX mode commands
     (idle-require feature))

   (setq idle-require-idle-delay 5)
   (idle-require-mode 1)
   #+END_SRC
   
** Sane defaults

   Emacs 기본 설정

   #+BEGIN_SRC emacs-lisp
   (setq auto-revert-interval 1            ; Refresh buffers fast
         custom-file (make-temp-file "")   ; Discard customization's
         default-input-method "TeX"        ; Use TeX when toggling input method
         echo-keystrokes 0.1               ; Show keystrokes asap
         inhibit-startup-message t         ; No splash screen please
         initial-scratch-message nil       ; Clean scratch buffer
         recentf-max-saved-items 100       ; Show more recent files
         ring-bell-function 'ignore        ; Quiet
         sentence-end-double-space nil)    ; No double space
   ;; Some mac-bindings interfere with Emacs bindings.
   (when (boundp 'mac-pass-command-to-system)
     (setq mac-pass-command-to-system nil))
   #+END_SRC

   =setq-default= 설정으로 buffer-local 기본값 설정

   #+BEGIN_SRC emacs-lisp
   (setq-default fill-column 79                    ; Maximum line width
                 truncate-lines t                  ; Don't fold lines
                 indent-tabs-mode nil              ; Use spaces instead of tabs
                 split-width-threshold 160         ; Split verticly by default
                 split-height-threshold nil        ; Split verticly by default
                 auto-fill-function 'do-auto-fill) ; Auto-fill-mode everywhere
   #+END_SRC

   =~/.emacs.d/site-lisp/= 추가 =load-path= 설정

   #+BEGIN_SRC emacs-lisp
   (let ((default-directory (concat user-emacs-directory "site-lisp/")))
     (when (file-exists-p default-directory)
       (setq load-path
             (append
              (let ((load-path (copy-sequence load-path)))
                (normal-top-level-add-subdirs-to-load-path)) load-path))))
   #+END_SRC

   Answering 단축 설정

   #+BEGIN_SRC emacs-lisp
   (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   자동 저장된 모든 파일을 =~/.emacs.d/autosaves= 에 넣도록 한다. 

   #+BEGIN_SRC emacs-lisp
   (defvar emacs-autosave-directory
     (concat user-emacs-directory "autosaves/")
     "This variable dictates where to put auto saves. It is set to a
     directory called autosaves located wherever your .emacs.d/ is
     located.")

   ;; Sets all files to be backed up and auto saved in a single directory.
   (setq backup-directory-alist
         `((".*" . ,emacs-autosave-directory))
         auto-save-file-name-transforms
         `((".*" ,emacs-autosave-directory t)))
   #+END_SRC

   =narrow-to-region= 경고 disabled

   #+BEGIN_SRC emacs-lisp
   (put 'narrow-to-region 'disabled nil)
   #+END_SRC

   =doc-view= 내용이 변경되면 자동으로 buffer 반영

   #+BEGIN_SRC emacs-lisp
   (add-hook 'doc-view-mode-hook 'auto-revert-mode)
   #+END_SRC

** Moes

   Emacs mode disable

   #+BEGIN_SRC emacs-lisp
   (dolist (mode
            '(tool-bar-mode                ; No toolbars, more room for text
              scroll-bar-mode              ; No scroll bars either
              menu-bar-mode                ; No menu bars either
              blink-cursor-mode))          ; The blinking cursor gets old
     (funcall mode 0))
   #+END_SRC

   Emacs mode enable

   #+BEGIN_SRC emacs-lisp
   (dolist (mode
            '(abbrev-mode                  ; E.g. sopl -> System.out.println
              column-number-mode           ; Show column number in mode line
              delete-selection-mode        ; Replace selected text
              dirtrack-mode                ; directory tracking in *shell*
              drag-stuff-global-mode       ; Drag stuff around
              global-company-mode          ; Auto-completion everywhere
              global-git-gutter-mode       ; Show changes latest commit
              global-prettify-symbols-mode ; Greek letters should look greek
              projectile-global-mode       ; Manage and navigate projects
              recentf-mode                 ; Recently opened files
              show-paren-mode              ; Highlight matching parentheses
              which-key-mode))             ; Available keybindings in popup
     (funcall mode 1))

   (when (version< emacs-version "24.4")
     (eval-after-load 'auto-compile
       '((auto-compile-on-save-mode 1))))  ; compile .el files on save
   #+END_SRC

** Visual

   Change the color-theme to =leuven=.

   #+BEGIN_SRC emacs-lisp
   (load-theme 'leuven t)
   #+END_SRC

   =leuven= or =materinal= 테마 변경 ~C-c .~

   #+BEGIN_SRC emacs-lisp
   (defun cycle-themes ()
     "Returns a function that lets you cycle your themes."
     (lexical-let ((themes '#1=(leuven material . #1#)))
       (lambda ()
         (interactive)
         ;; Rotates the thme cycle and changes the current theme.
         (load-theme (car (setq themes (cdr themes))) t))))
   #+END_SRC

   =Consolas= Font 설정 

   #+BEGIN_SRC emacs-lisp
   ;; |12345678|   |
   ;; |--------|---|
   ;; |가나다라|   |
   (when (eq system-type 'darwin)
     (set-face-attribute 'default nil
                         :family "D2Coding"
                         :height 150
                         :weight 'ultra-light))

   (when (eq system-type 'windows-nt)
     (set-face-attribute 'default nil
                         :family "D2Coding"
                         :height 120
                         :weight 'ultra-light))
   #+END_SRC

   [[http://www.eskimo.com/~seldon/diminish.el][diminish.el]] allows you to hide or abbreviate their presence in the
   modeline. I rarely look at the modeline to find out what minor-modes are
   enabled, so I disable every global minor-mode, and some for lisp editing.

   To ensure that the mode is loaded before diminish it, we should use
   ~with-eval-after-load~. To avoid typing this multiple times a small macro
   is provided.

   #+BEGIN_SRC emacs-lisp
   (defmacro safe-diminish (file mode &optional new-name)
     `(with-eval-after-load ,file
        (diminish ,mode ,new-name)))

   (diminish 'auto-fill-function)
   (safe-diminish "eldoc" 'eldoc-mode)
   (safe-diminish "helm-mode" 'helm-mode)
   (safe-diminish "projectile" 'projectile-mode)
   (safe-diminish "paredit" 'paredit-mode "()")
   #+END_SRC

   git 변경 사항 표시 [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]]

   #+BEGIN_SRC emacs-lisp
   (require 'git-gutter-fringe)

   (dolist (p '((git-gutter:added    . "#0c0")
                (git-gutter:deleted  . "#c00")
                (git-gutter:modified . "#c0c")))
     (set-face-foreground (car p) (cdr p))
     (set-face-background (car p) (cdr p)))
   #+END_SRC

   =prettify-symbols-mode=

   #+BEGIN_SRC emacs-lisp
   (setq-default prettify-symbols-alist '(("lambda" . ?λ)
                                          ("delta" . ?Δ)
                                          ("gamma" . ?Γ)
                                          ("phi" . ?φ)
                                          ("psi" . ?ψ)))
   #+END_SRC
** Completion

   [[http://company-mode.github.io/][company-mode]] 자동완성 설정

   #+BEGIN_SRC emacs-lisp
   (setq company-idle-delay 0
         company-echo-delay 0
         company-dabbrev-downcase nil
         company-minimum-prefix-length 2
         company-selection-wrap-around t
         company-transformers '(company-sort-by-occurrence
                                company-sort-by-backend-importance))
   #+END_SRC

** Helm

   #+BEGIN_SRC emacs-lisp
   (require 'helm)
   (require 'helm-config)

   (setq helm-split-window-in-side-p t
         helm-M-x-fuzzy-match t
         helm-buffers-fuzzy-matching t
         helm-recentf-fuzzy-match t
         helm-move-to-line-cycle-in-source t
         projectile-completion-system 'helm)

   (when (executable-find "ack")
     (setq helm-grep-default-command
           "ack -Hn --no-group --no-color %e %p %f"
           helm-grep-default-recurse-command
           "ack -H --no-group --no-color %e %p %f"))

   (set-face-attribute 'helm-selection nil :background "cyan")

   (helm-mode 1)
   (helm-projectile-on)
   (helm-adaptive-mode 1)
   #+END_SRC

*** Helm dash

    #+BEGIN_SRC emacs-lisp
    (setq helm-dash-browser-func 'eww)
    (add-hook 'emacs-lisp-mode-hook
              (lambda () (setq-local helm-dash-docsets '("Emacs Lisp"))))
    (add-hook 'erlang-mode-hook
              (lambda () (setq-local helm-dash-docsets '("Erlang"))))
    (add-hook 'java-mode-hook
              (lambda () (setq-local helm-dash-docsets '("Java"))))
    (add-hook 'haskell-mode-hook
              (lambda () (setq-local helm-dash-docsets '("Haskell"))))
    (add-hook 'clojure-mode-hook
              (lambda () (setq-local helm-dash-docsets '("Clojure"))))
    #+END_SRC

** mu4e and offlineimap

   I might not be at a computer using my very specific mail-setup, but if my
   mail-folder exists, then it's probably safe to load.

   #+BEGIN_SRC emacs-lisp
   (defvar load-mail-setup (file-exists-p "~/Maildir"))
   #+END_SRC

   I use [[http://www.djcbsoftware.nl/code/mu/mu4e.html][mu4e]] (which is a part of [[http://www.djcbsoftware.nl/code/mu/][mu]]) along with [[http://docs.offlineimap.org/en/latest/][offlineimap]] on one of my
   computers.
*** COMMENT prepare
    #+BEGIN_EXAMPLE
    [general]
    accounts = Gmail
    maxsyncaccounts = 3

    [Account Gmail]
    localrepository = Local
    remoterepository = Remote

    [Repository Local]
    type = Maildir
    localfolders = ~/Maildir

    [Repository Remote]
    type = Gmail 
    remoteuser = thkim256@gmail.com
    ssl = yes
    starttls = no
    sslcacertfile = /usr/local/etc/openssl/cert.pem
    auth_mechanisms = XOAUTH2
    oauth2_client_id = {CLIENT_ID}
    oauth2_client_secret = {CLIENT_SECRET}
    oauth2_request_url = https://accounts.google.com/o/oauth2/token
    oauth2_refresh_token = {REFRESH_TOKEN}
    # maxconnections = 1
    # decodefoldernames = yes 
    # oauth2_access_token = 
    #+END_EXAMPLE

    #+BEGIN_SRC sh :tangle no
    git clone https://github.com/google/gmail-oauth2-tools

    python python/oauth2.py \
    --client_id={CLIENT_ID} \
    --client_secret={CLIENT_SECRET} \
    --generate_oauth2_token
    #+END_SRC
*** mu4e

    mu4e must be informed where it can find your mail and where the
    different folders of interest are located. Some additional mu4e-tweaks
    are supplied here as well.

    ~message-insert-signature~ is an existing Emacs function, that adds your
    signature prefixed by a ~"-- "~ at the end of the email, which is a
    convention I don't really follow. I redefine it as a function that adds
    some newlines and my signature at the top of the email.

    #+BEGIN_SRC emacs-lisp
    (when load-mail-setup
      (eval-after-load 'mu4e
        '(progn
           ;; use mu4e for e-mail in emacs
           (setq mail-user-agent 'mu4e-user-agent)

           (when (eq system-type 'windows-nt)
             (setq mu4e-mu-binary "c:/cygwin64/usr/local/bin/mu.exe"))

           ;; Some basic mu4e settings.
           (setq mu4e-maildir           "~/Maildir"     ; top-level Maildir
                 mu4e-sent-folder       "/[Gmail].Sent Mail"    ; folder for sent messages
                 mu4e-drafts-folder     "/[Gmail].Drafts"  ; unfinished messages
                 mu4e-trash-folder      "/[Gmail].Trash"   ; trashed messages
                 mu4e-get-mail-command  "offlineimap"    ; offlineimap to fetch mail
                 ;; mu4e-compose-signature "- thkim256"     ; Sign my name
                 mu4e-update-interval   (* 5 60)         ; update every 5 min
                 mu4e-confirm-quit      nil              ; just quit
                 mu4e-view-show-images  t                ; view images
                 mu4e-html2text-command
                 "html2text")                      ; use utf-8

           ;; setup some handy shortcuts
           ;; you can quickly switch to your Inbox -- press ``ji''
           ;; then, when you want archive some messages, move them to
           ;; the 'All Mail' folder by pressing ``ma''.
           (setq mu4e-maildir-shortcuts
                 '( ("/INBOX"               . ?i)
                    ("/[Gmail].Sent Mail"   . ?s)
                    ("/[Gmail].Trash"       . ?t)
                    ("/[Gmail].All Mail"    . ?a)))

           ;; something about ourselves
           (setq
            user-mail-address "thkim256@gmail.com"
            user-full-name  "TaeHyung Kim"
            mu4e-compose-signature
            (concat
             "Foo X. Bar\n"
             "http://www.example.com\n"))
           ;; sending mail -- replace USERNAME with your gmail username
           ;; also, make sure the gnutls command line utils are installed
           ;; package 'gnutls-bin' in Debian/Ubuntu

           (require 'smtpmail)
           (setq message-send-mail-function 'smtpmail-send-it
                 starttls-use-gnutls t
                 smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
                 smtpmail-auth-credentials
                 '(("smtp.gmail.com" 587 "thkim256@gmail.com" nil))
                 smtpmail-default-smtp-server "gmail.com"
                 smtpmail-smtp-server "smtp.gmail.com"
                 smtpmail-smtp-service 587)

           ;; Register file types that can be handled by ImageMagick.
           (when (fboundp 'imagemagick-register-types)
             (imagemagick-register-types))

           (add-hook 'mu4e-compose-mode-hook
                     (lambda ()
                       (auto-fill-mode 0)
                       (visual-line-mode 1)
                       (ispell-change-dictionary "norsk")))

           (add-hook 'mu4e-view-mode-hook (lambda () (visual-line-mode 1)))

           (defun message-insert-signature ()
             (goto-char (point-min))
             (search-forward-regexp "^$")
             (insert "\n\n\n" mu4e-compose-signature))))

      (autoload 'mu4e "mu4e" nil t))
    #+END_SRC

    #+RESULTS:

*** mu4e [[https://github.com/iqbalansari/mu4e-alert][mu4e-alert]]
    
    데스크탑 알림 설정

    #+BEGIN_SRC emacs-lisp
    ;; Choose the style you prefer for desktop notifications
    ;; If you are on Linux you can use
    ;; 1. notifications - Emacs lisp implementation of the Desktop Notifications API
    ;; 2. libnotify     - Notifications using the `notify-send' program, requires `notify-send' to be in PATH
    ;;
    ;; On Mac OSX you can set style to
    ;; 1. notifier      - Notifications using the `terminal-notifier' program, requires `terminal-notifier' to be in PATH
    ;; 1. growl         - Notifications using the `growl' program, requires `growlnotify' to be in PATH
    (mu4e-alert-set-default-style 'libnotify)
    (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
    #+END_SRC
    
    읽지 않은 메일 mode line 표시

    #+BEGIN_SRC emacs-lisp
    (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
    #+END_SRC
** Org

   =org-agenda=, =org-capture= 설정
   
   #+BEGIN_SRC emacs-lisp
   (setq org-agenda-files '("~/Dropbox/agenda.org")  ; A list of agenda files
         org-agenda-default-appointment-duration 120 ; 2 hours appointments
         org-capture-templates                       ; Template for adding tasks
         '(("t" "TODOs" entry (file+headline "~/Dropbox/agenda.org" "TODOs")
            "** TODO %?" :prepend t)
           ("r" "Readmine" entry (file+olp "~/Dropbox/agenda.org" "TODOs" "Redmine")
            "*** TODO %?" :prepend t)
           ("m" "Misc" entry (file+headline "~/Dropbox/agenda.org" "Misc")
            "** %?\n   SCHEDULED: %T" :prepend t)))
   #+END_SRC

   source-blocks 편집 시, 테마 설정

   #+BEGIN_SRC emacs-lisp
   (setq org-src-fontify-natively t
         org-src-tab-acts-natively t
         org-confirm-babel-evaluate nil
         org-edit-src-content-indentation 0)
   #+END_SRC
   
   org babel 실행 추가
   
   #+BEGIN_SRC emacs-lisp
   (org-babel-do-load-languages
    'org-babel-load-languages
    '((python . t)
      (ditaa . t)
      (java . t)
      (go . t)
      (js . t)
      (shell . t)
      (plantuml . t)
     ; (clojure . t)
     ; (clojurescript . t)
      ))
   #+END_SRC

   org label 실행이후, 이미지 보이기


   인용 부호 문제점 수정
   E.g. ="this string"=

   #+BEGIN_SRC emacs-lisp
   ;;(require 'org)
   (eval-after-load "org"
     '(progn
        (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\n,")
        (custom-set-variables `(org-emphasis-alist ',org-emphasis-alist))))
   #+END_SRC
   
** Evil
   
   Vim 모드 사용
   
   #+BEGIN_SRC emacs-lisp
   (require 'evil)
   (evil-mode t)
   #+END_SRC

** Interactive functions
   <<sec:defuns>>

   =just-one-space= removes all whitespace around a point - giving it a
   negative argument it removes newlines as well. We wrap a interactive
   function around it to be able to bind it to a key. In Emacs 24.4
   =cycle-spacing= was introduced, and it works like =just-one-space=, but
   when run in succession it cycles between one, zero and the original
   number of spaces.

   #+BEGIN_SRC emacs-lisp
   (defun cycle-spacing-delete-newlines ()
     "Removes whitespace before and after the point."
     (interactive)
     (if (version< emacs-version "24.4")
         (just-one-space -1)
       (cycle-spacing -1)))
   #+END_SRC

   Often I want to find other occurrences of a word I'm at, or more
   specifically the symbol (or tag) I'm at. The
   =isearch-forward-symbol-at-point= in Emacs 24.4 works well for this, but
   I don't want to be bothered with the =isearch= interface. Rather jump
   quickly between occurrences of a symbol, or if non is found, don't do
   anything.

   #+BEGIN_SRC emacs-lisp
   (defun jump-to-symbol-internal (&optional backwardp)
     "Jumps to the next symbol near the point if such a symbol
   exists. If BACKWARDP is non-nil it jumps backward."
     (let* ((point (point))
            (bounds (find-tag-default-bounds))
            (beg (car bounds)) (end (cdr bounds))
            (str (isearch-symbol-regexp (find-tag-default)))
            (search (if backwardp 'search-backward-regexp
                      'search-forward-regexp)))
       (goto-char (if backwardp beg end))
       (funcall search str nil t)
       (cond ((<= beg (point) end) (goto-char point))
             (backwardp (forward-char (- point beg)))
             (t  (backward-char (- end point))))))

   (defun jump-to-previous-like-this ()
     "Jumps to the previous occurrence of the symbol at point."
     (interactive)
     (jump-to-symbol-internal t))

   (defun jump-to-next-like-this ()
     "Jumps to the next occurrence of the symbol at point."
     (interactive)
     (jump-to-symbol-internal))
   #+END_SRC

   I sometimes regret killing the =*scratch*=-buffer, and have realized I
   never want to actually kill it. I just want to get it out of the way, and
   clean it up. The function below does just this for the
   =*scratch*=-buffer, and works like =kill-this-buffer= for any other
   buffer. It removes all buffer content and buries the buffer (this means
   making it the least likely candidate for =other-buffer=).

   #+BEGIN_SRC emacs-lisp
   (defun kill-this-buffer-unless-scratch ()
     "Works like `kill-this-buffer' unless the current buffer is the
   ,*scratch* buffer. In witch case the buffer content is deleted and
   the buffer is buried."
     (interactive)
     (if (not (string= (buffer-name) "*scratch*"))
         (kill-this-buffer)
       (delete-region (point-min) (point-max))
       (switch-to-buffer (other-buffer))
       (bury-buffer "*scratch*")))
   #+END_SRC

   To duplicate either selected text or a line we define this interactive
   function.

   #+BEGIN_SRC emacs-lisp
   (defun duplicate-thing (comment)
     "Duplicates the current line, or the region if active. If an argument is
   given, the duplicated region will be commented out."
     (interactive "P")
     (save-excursion
       (let ((start (if (region-active-p) (region-beginning) (point-at-bol)))
             (end   (if (region-active-p) (region-end) (point-at-eol))))
         (goto-char end)
         (unless (region-active-p)
           (newline))
         (insert (buffer-substring start end))
         (when comment (comment-region start end)))))
   #+END_SRC

   To tidy up a buffer we define this function borrowed from [[https://github.com/simenheg][simenheg]].

   #+BEGIN_SRC emacs-lisp
   (defun tidy ()
     "Ident, untabify and unwhitespacify current buffer, or region if active."
     (interactive)
     (let ((beg (if (region-active-p) (region-beginning) (point-min)))
           (end (if (region-active-p) (region-end) (point-max))))
       (indent-region beg end)
       (whitespace-cleanup)
       (untabify beg (if (< end (point-max)) end (point-max)))))
   #+END_SRC

   Org mode does currently not support synctex (which enables you to jump from
   a point in your TeX-file to the corresponding point in the pdf), and it
   [[http://comments.gmane.org/gmane.emacs.orgmode/69454][seems like a tricky problem]].

   Calling this function from an org-buffer jumps to the corresponding section
   in the exported pdf (given that the pdf-file exists), using pdf-tools.

   #+BEGIN_SRC emacs-lisp
   (defun org-sync-pdf ()
     (interactive)
     (let ((headline (nth 4 (org-heading-components)))
           (pdf (concat (file-name-base (buffer-name)) ".pdf")))
       (when (file-exists-p pdf)
         (find-file-other-window pdf)
         (pdf-links-action-perform
          (cl-find headline (pdf-info-outline pdf)
                   :key (lambda (alist) (cdr (assoc 'title alist)))
                   :test 'string-equal)))))
   #+END_SRC
   
   자동 들여쓰기 지원
   #+BEGIN_SRC emacs-lisp
   (defun indent-buffer()
     (interactive)
     (indent-region (point-min) (point-max)))
   #+END_SRC

** Advice
   
   An advice can be given to a function to make it behave differently. This
   advice makes =eval-last-sexp= (bound to =C-x C-e=) replace the sexp with
   the value.

   #+BEGIN_SRC emacs-lisp
   (defadvice eval-last-sexp (around replace-sexp (arg) activate)
     "Replace sexp when called with a prefix argument."
     (if arg
         (let ((pos (point)))
           ad-do-it
           (goto-char pos)
           (backward-kill-sexp)
           (forward-sexp))
       ad-do-it))
   #+END_SRC

   =load-theme=  toggle 처리

   #+BEGIN_SRC emacs-lisp
   (defadvice load-theme
       (before disable-before-load (theme &optional no-confirm no-enable) activate)
     (mapc 'disable-theme custom-enabled-themes))
   #+END_SRC

** global-scale-mode

   #+BEGIN_SRC emacs-lisp
   (lexical-let* ((default (face-attribute 'default :height))
                  (size default))

     (defun global-scale-default ()
       (interactive)
       (setq size default)
       (global-scale-internal size))

     (defun global-scale-up ()
       (interactive)
       (global-scale-internal (incf size 20)))

     (defun global-scale-down ()
       (interactive)
       (global-scale-internal (decf size 20)))

     (defun global-scale-internal (arg)
       (set-face-attribute 'default (selected-frame) :height arg)
       (set-temporary-overlay-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "C-=") 'global-scale-up)
          (define-key map (kbd "C-+") 'global-scale-up)
          (define-key map (kbd "C--") 'global-scale-down)
          (define-key map (kbd "C-0") 'global-scale-default) map))))
   #+END_SRC
   
* Mode specific
** Shell

   Inspired by [[https://github.com/torenord/.emacs.d][torenord]], I maintain quick access to shell buffers with bindings
   ~M-1~ to ~M-9~. In addition, the ~M-§~ (on an international English
   keyboard) is bound toggle between the last visited shell, and the last
   visited non-shell buffer. The following functions facilitate this, and are
   bound in the [[Key bindings]] section.

   #+BEGIN_SRC emacs-lisp
   (lexical-let ((last-shell ""))
     (defun toggle-shell ()
       (interactive)
       (cond ((string-match-p "^\\*shell<[1-9][0-9]*>\\*$" (buffer-name))
              (goto-non-shell-buffer))
             ((get-buffer last-shell) (switch-to-buffer last-shell))
             (t (shell (setq last-shell "*shell<1>*")))))

     (defun switch-shell (n)
       (let ((buffer-name (format "*shell<%d>*" n)))
         (setq last-shell buffer-name)
         (cond ((get-buffer buffer-name)
                (switch-to-buffer buffer-name))
               (t (shell buffer-name)
                  (rename-buffer buffer-name)))))

     (defun goto-non-shell-buffer ()
       (let* ((r "^\\*shell<[1-9][0-9]*>\\*$")
              (shell-buffer-p (lambda (b) (string-match-p r (buffer-name b))))
              (non-shells (cl-remove-if shell-buffer-p (buffer-list))))
         (when non-shells
           (switch-to-buffer (first non-shells))))))
   #+END_SRC

   Don't query whether or not the ~shell~-buffer should be killed, just kill
   it.

   #+BEGIN_SRC emacs-lisp
   (defadvice shell (after kill-with-no-query nil activate)
     (set-process-query-on-exit-flag (get-buffer-process ad-return-value) nil))
   #+END_SRC

   =C-l=: =clear= 처리

   #+BEGIN_SRC emacs-lisp
   (defun clear-comint ()
     "Runs `comint-truncate-buffer' with the
   `comint-buffer-maximum-size' set to zero."
     (interactive)
     (let ((comint-buffer-maximum-size 0))
       (comint-truncate-buffer)))
   #+END_SRC

   =clear-shell=

   #+BEGIN_SRC emacs-lisp
   (add-hook 'comint-mode-hook (lambda () (local-set-key (kbd "C-l") 'clear-comint)))
   #+END_SRC
   
   Company Mode off

   #+BEGIN_SRC emacs-lisp
   (add-hook 'shell-mode-hook (lambda () (company-mode -1)))
   #+END_SRC

*** Window Cygwin
    
    cygwin support

    #+BEGIN_SRC emacs-lisp
    (let* ((cygwin-root "c:/cygwin64")
           (cygwin-bin (concat cygwin-root "/bin")))
      (when (and (eq 'windows-nt system-type)
                 (file-readable-p cygwin-root))

        (setq exec-path (cons cygwin-bin exec-path))
        (setenv "PATH" (concat cygwin-bin ";" (getenv "PATH")))

        ;; By default use the Windows HOME.
        ;; Otherwise, uncomment below to set a HOME
        ;;      (setenv "HOME" (concat cygwin-root "/home/eric"))

        ;; NT-emacs assumes a Windows shell. Change to bash.
        (setq shell-file-name "bash")
        (setenv "SHELL" shell-file-name) 
        (setq explicit-shell-file-name shell-file-name) 

        ;; This removes unsightly ^M characters that would otherwise
        ;; appear in the output of java applications.
        (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m)))
    #+END_SRC
   
** Lisp

   =Paredit=

   #+BEGIN_SRC emacs-lisp
   (dolist (mode '(cider-repl-mode
                   clojure-mode
                   ielm-mode
                   geiser-repl-mode
                   slime-repl-mode
                   lisp-mode
                   emacs-lisp-mode
                   lisp-interaction-mode
                   scheme-mode))
     ;; add paredit-mode to all mode-hooks
     (add-hook (intern (concat (symbol-name mode) "-hook")) 'paredit-mode))
   #+END_SRC

*** Emacs Lisp

    In =emacs-lisp-mode= we can enable =eldoc-mode= to display information
    about a function or a variable in the echo area.

    #+BEGIN_SRC emacs-lisp
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    #+END_SRC

*** Clojure

    #+BEGIN_SRC emacs-lisp
    (add-hook 'cider-repl-mode-hook (lambda () (local-set-key (kbd "C-l") 'cider-repl-clear-buffer)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
    (setq cider-cljs-lein-repl
          "(do (require 'figwheel-sidecar.repl-api)
               (figwheel-sidecar.repl-api/start-figwheel!)
               (figwheel-sidecar.repl-api/cljs-repl))")
    #+END_SRC

*** Common lisp

    I use [[http://www.common-lisp.net/project/slime/][Slime]] along with =lisp-mode= to edit Common Lisp code. Slime
    provides code evaluation and other great features, a must have for a
    Common Lisp developer. [[http://www.quicklisp.org/beta/][Quicklisp]] is a library manager for Common Lisp,
    and you can install Slime following the instructions from the site along
    with this snippet.

    #+BEGIN_SRC emacs-lisp
    (defun activate-slime-helper ()
      (when (file-exists-p "~/.quicklisp/slime-helper.el")
        (load (expand-file-name "~/.quicklisp/slime-helper.el"))
        (define-key slime-repl-mode-map (kbd "C-l")
          'slime-repl-clear-buffer))
      (remove-hook 'lisp-mode-hook #'activate-slime-helper))

    (add-hook 'lisp-mode-hook #'activate-slime-helper)
    #+END_SRC

    We can specify what Common Lisp program Slime should use (I use SBCL).

    #+BEGIN_SRC emacs-lisp
    (setq inferior-lisp-program "sbcl")
    #+END_SRC

    More sensible =loop= indentation, borrowed from [[https://github.com/simenheg][simenheg]].

    #+BEGIN_SRC emacs-lisp
    (setq lisp-loop-forms-indentation   6
          lisp-simple-loop-indentation  2
          lisp-loop-keyword-indentation 6)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp

    #+END_SRC

*** Scheme

    [[http://www.nongnu.org/geiser/][Geiser]] provides features similar to Slime for Scheme editing. Everything
    works pretty much out of the box, we only need to add auto completion,
    and specify which scheme-interpreter we prefer.

    #+BEGIN_SRC emacs-lisp
    (eval-after-load "geiser"
      '(setq geiser-active-implementations '(guile)))
    #+END_SRC

** Java and C

   C 모드에서 =C-c C-c= compile 단축 설정

   #+BEGIN_SRC emacs-lisp
   (defun c-setup ()
     (local-set-key (kbd "C-c C-c") 'compile))

   (add-hook 'c-mode-common-hook 'c-setup)
   #+END_SRC

   Java abbrevs 설정

   #+BEGIN_SRC emacs-lisp
   (define-abbrev-table 'java-mode-abbrev-table
     '(("psv" "public static void main(String[] args) {" nil 0)
       ("sopl" "System.out.println" nil 0)
       ("sop" "System.out.printf" nil 0)))
   #+END_SRC

   Java mode =abbrev-mode= enable

   #+BEGIN_SRC emacs-lisp
   (defun java-setup ()
     (abbrev-mode t)
     (setq-local compile-command (concat "javac " (buffer-name))))

   (add-hook 'java-mode-hook 'java-setup)
   #+END_SRC
** Markdown

   This makes =.md=-files open in =markdown-mode=.

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
   #+END_SRC
** Go

   Golang 관련 설정
   
   #+BEGIN_SRC sh :tangle no
   go get golang.org/x/tools/cmd/...
   go get github.com/rogpeppe/godef
   go get github.com/nsf/gocode
   go get github.com/fatih/gomodifytags
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (require 'go-mode)
   (require 'go-direx)
   (add-to-list 'exec-path "~/go/bin")
   (eval-after-load 'go-mode
     '(progn
        (add-hook 'before-save-hook 'gofmt-before-save)
        (when (executable-find "goimports")
          (add-hook 'go-mode-hook
                    (lambda ()
                      (setq gofmt-command "goimports"))))))

   (defun my-go-mode-hook ()
     (add-hook 'before-save-hook 'gofmt-before-save)
     (if (not (string-match "go" compile-command))
         (set (make-local-variable 'compile-command)
              "go build -v && go test -v && go vet"))
     (define-key global-map "\M-." 'godef-jump)
     (local-set-key (kbd "M-.") 'godef-jump)
     (local-set-key (kbd "M-*") 'pop-tag-mark)
     (local-set-key (kbd "C-c C-c") 'compile)
     (setq tab-width 2)
     (setq indent-tabs-mode t)
     (set (make-local-variable 'company-backends) '(company-go)))

   (add-hook 'go-mode-hook 'my-go-mode-hook)
   #+END_SRC
** plantuml-mode
   
   default는 로컬에 있는 jar 형식을 사용
   
   #+BEGIN_SRC emacs-lisp
   (setq plantuml-default-exec-mode 'jar)
   (setq plantuml-jar-path (concat user-emacs-directory "/bin/plantuml/plantuml.jar"))
   #+END_SRC
   
   plantuml에 대한 org-babel 설정

   #+BEGIN_SRC emacs-lisp
   (setq org-plantuml-jar-path
         (expand-file-name (concat user-emacs-directory "/bin/plantuml/plantuml.jar")))
   ;; (setq org-ditaa-jar-path
   ;;       (expand-file-name (concat user-emacs-directory "/bin/ditaa/ditaa0_9.jar")))
   #+END_SRC
* Encoding

   인코딩 설정.

   기존 설정에서 해당 옵션이 무시될 때가 있어서 Key bindings 직전에 수행하도록
   한다.

   #+BEGIN_SRC emacs-lisp
   (set-language-environment "UTF-8")
   (when (eq system-type 'windows-nt)
     (set-language-environment "Korean")
     (set-terminal-coding-system 'utf-8)
     (set-default-coding-systems 'utf-8)
     (prefer-coding-system 'utf-8))

   ;; (set-language-environment "Korean")
   ;; (set-terminal-coding-system 'utf-8)
   ;; (set-default-coding-systems 'utf-8)
   ;; (prefer-coding-system 'utf-8)
   ;; (when (and window-system (eq system-type 'darwin))
   ;;   (set-selection-coding-system 'utf-8)
   ;;   (set-keyboard-coding-system 'utf-8)
   ;;   (setq locale-coding-system 'utf-8))
   #+END_SRC
* Key bindings

  =custom-bindings-map= 에 custom 바인딩 설정하고, =minor-mode= 에 할당하여
  활성화한다.

  모든 함수가 실제로 정의되도록 init 파일의 끝에 이것을 유지
  
  C.f. [[http://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs][this StackOverflow post]]

  #+BEGIN_SRC emacs-lisp
  (defvar custom-bindings-map (make-keymap)
    "A keymap for custom bindings.")
  #+END_SRC

** Bindings for Change Language

   #+BEGIN_SRC emacs-lisp
   (when (eq system-type 'windows-nt)
     (global-set-key (kbd "<S-kana>") 'toggle-input-method)
     (global-set-key (kbd "<kana>") 'toggle-input-method))
   #+END_SRC
** Bindings for eval-defun

   #+BEGIN_SRC emacs-lisp
   (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-defun)
   (define-key lisp-interaction-mode-map (kbd "C-c C-c") 'eval-defun)
   #+END_SRC
** Bindings for [[https://github.com/abo-abo/define-word][define-word]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C-c D") 'define-word-at-point)
  #+END_SRC

** Bindings for [[https://github.com/magnars/expand-region.el][expand-region]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C->")  'er/expand-region)
  (define-key custom-bindings-map (kbd "C-<")  'er/contract-region)
  #+END_SRC

** Bindings for [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C-c e")  'mc/edit-lines)
  (define-key custom-bindings-map (kbd "C-c a")  'mc/mark-all-like-this)
  (define-key custom-bindings-map (kbd "C-c n")  'mc/mark-next-like-this)
  #+END_SRC

** Bindings for [[http://magit.github.io][Magit]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C-c m") 'magit-status)
  #+END_SRC

** Bindings for [[http://company-mode.github.io/][company-mode]]
   
  #+BEGIN_SRC emacs-lisp
  (define-key company-active-map (kbd "C-d") 'company-show-doc-buffer)
  (define-key company-active-map (kbd "C-n") 'company-select-next)
  (define-key company-active-map (kbd "C-p") 'company-select-previous)
  (define-key company-active-map (kbd "<tab>") 'company-complete)

  (define-key company-mode-map (kbd "C-:") 'helm-company)
  (define-key company-active-map (kbd "C-:") 'helm-company)
  #+END_SRC

** Bindings for [[http://emacs-helm.github.io/helm/][Helm]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C-c h")   'helm-command-prefix)
  (define-key custom-bindings-map (kbd "M-x")     'helm-M-x)
  (define-key custom-bindings-map (kbd "M-y")     'helm-show-kill-ring)
  (define-key custom-bindings-map (kbd "C-x b")   'helm-mini)
  (define-key custom-bindings-map (kbd "C-x C-f") 'helm-find-files)
  (define-key custom-bindings-map (kbd "C-c h d") 'helm-dash-at-point)
  (define-key custom-bindings-map (kbd "C-c h o") 'helm-occur)
  (define-key custom-bindings-map (kbd "C-c h g") 'helm-google-suggest)
  (define-key custom-bindings-map (kbd "C-c r")   'helm-recentf)
  (define-key custom-bindings-map (kbd "M-i")     'helm-swoop)
  (define-key custom-bindings-map (kbd "M-I")     'helm-multi-swoop-all)

  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-i")   'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-z")   'helm-select-action)
  #+END_SRC

** Bindings for [[https://golang.org/][Go]]
   
   [[https://github.com/syohex/emacs-go-direx][go-direx]]

   #+BEGIN_SRC emacs-lisp
   (define-key go-mode-map (kbd "C-c C-j") 'go-direx-pop-to-buffer)
   #+END_SRC

** Bindings for built-ins

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "M-u")         'upcase-dwim)
  (define-key custom-bindings-map (kbd "M-c")         'capitalize-dwim)
  (define-key custom-bindings-map (kbd "M-l")         'downcase-dwim)
  (define-key custom-bindings-map (kbd "M-]")         'other-frame)
  (define-key custom-bindings-map (kbd "C-j")         'newline-and-indent)
  (define-key custom-bindings-map (kbd "C-c s")       'ispell-word)
  (define-key custom-bindings-map (kbd "C-c c")       'org-capture)
  (define-key custom-bindings-map (kbd "C-x m")       'mu4e)
  (define-key custom-bindings-map (kbd "C-c <up>")    'windmove-up)
  (define-key custom-bindings-map (kbd "C-c <down>")  'windmove-down)
  (define-key custom-bindings-map (kbd "C-c <left>")  'windmove-left)
  (define-key custom-bindings-map (kbd "C-c <right>") 'windmove-right)
  (define-key custom-bindings-map (kbd "C-c t")
    (lambda () (interactive) (org-agenda nil "n")))
  #+END_SRC

** Bindings for functions defined [[sec:defuns][above]]

  #+BEGIN_SRC emacs-lisp
  (define-key global-map          (kbd "C-M-f")   'toggle-frame-fullscreen)
  (define-key global-map          (kbd "M-p")     'jump-to-previous-like-this)
  (define-key global-map          (kbd "M-n")     'jump-to-next-like-this)
  (define-key custom-bindings-map (kbd "M-,")     'jump-to-previous-like-this)
  (define-key custom-bindings-map (kbd "M-.")     'jump-to-next-like-this)
  (define-key custom-bindings-map (kbd "C-c .")   (cycle-themes))
  (define-key custom-bindings-map (kbd "C-x k")   'kill-this-buffer-unless-scratch)
  (define-key custom-bindings-map (kbd "C-c C-0") 'global-scale-default)
  (define-key custom-bindings-map (kbd "C-c C-=") 'global-scale-up)
  (define-key custom-bindings-map (kbd "C-c C-+") 'global-scale-up)
  (define-key custom-bindings-map (kbd "C-c C--") 'global-scale-down)
  (define-key custom-bindings-map (kbd "C-c j")   'cycle-spacing-delete-newlines)
  (define-key custom-bindings-map (kbd "C-c d")   'duplicate-thing)
  (define-key custom-bindings-map (kbd "<C-tab>") 'tidy)
  (define-key custom-bindings-map (kbd "M-§")     'toggle-shell)
  (dolist (n (number-sequence 1 9))
    (global-set-key (kbd (concat "M-" (int-to-string n)))
                    (lambda () (interactive) (switch-shell n))))
  (define-key custom-bindings-map (kbd "C-c C-q")
    '(lambda ()
       (interactive)
       (focus-mode 1)
       (focus-read-only-mode 1)))
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-'") 'org-sync-pdf))
  #+END_SRC

  Lastly we need to activate the map by creating and activating the
  =minor-mode=.

  #+BEGIN_SRC emacs-lisp
  (define-minor-mode custom-bindings-mode
    "A mode that activates custom-bindings."
    t nil custom-bindings-map)
  #+END_SRC
